
"""
@version: Python 3.7
@author: Huihui Xu
@email: huihui.xu@pitt.edu
@date: 10/28/2021
"""
import numpy as np

def gaussian(x, u, sigma):
	f = (1/(sigma*np.sqrt(2*np.pi)))*np.exp(-0.5*((x-u)/sigma)**2)
	return f


# E step
def E_step(data, ps, us, sigmas):
	"""
	Parameters: 
	data: observed data points{x_1, ..., x_n} in R^d
	ps:{p_1,..p_k} soft counts
	us:{u^1,..u^k} means of k gaussian distributions, where k is number of clusterings
	sigmas:{sigma^2_1,..sigma^2_k} vairance of k gaussian distributions, where k is number of clusterings

	"""
	# to store all the points' posterior probabilities
	points_posters = []
	
	# P(x was generated by cluster j | x, thetas)
	def probj(point, p, u, sigma):
		prior = gaussian(point,u,sigma)
		likelihood = p
		return prior*likelihood

	# compute denominator 
	def denom(point, ps, us, sigmas):
		"""
		Return:
		projs: the conditional probability p(i | j) 
		denominator: total probability of point that belongs to clustering 1..k
		"""

		topic_num = len(ps)
		projs = []
		denominator = 0
		for k in range(topic_num):
			p,u,sigma = ps[k],us[k],sigmas[k]
			projs.append(probj(point, p,u,sigma))
			denominator += probj(point, p, u, sigma)
		return projs, denominator

	# iterate every point in the dataset, and compute the posterior probabilities
	for point in data:
		projs, denominator = denom(point, ps, us, sigmas)
		projs = np.array(projs)
		# all the posterior probabilities of point was generated by clusters1..k 
		posters = projs/denominator
		points_posters.append(posters)
	return points_posters

# M_step
def M_step(posters, data, ps, us, sigmas):
	posters = np.array(posters)
	data = np.array(data).reshape(-1,1)
	# updated means
	new_us = np.sum(np.multiply(data,posters), axis = 0)/np.sum(posters, axis = 0)
	# updated ps
	new_ps = np.sum(posters, axis = 0)/len(data)
	# updated sigmas
	#
	new_sigmas = []
	for i,new_u in enumerate(new_us):
		posters_ = posters[:,i].reshape(-1,1)
		new_sigma = np.sum(np.multiply(np.square(data - new_u),posters_))/np.sum(posters_, axis = 0)
		new_sigmas.append(new_sigma.item())
	new_sigmas = [np.sqrt(_) for _ in new_sigmas]
	return new_ps,new_us,new_sigmas  

if __name__ == "__main__":
	us = [-3,2]
	sigmas = [2,2]
	ps = [0.5,0.5]
	data = [-1, 0, 4, 5, 6]
	points_posters = E_step(data, ps, us, sigmas)
	new_ps, new_us, new_sigmas = M_step(points_posters, data, ps, us, sigmas)

	print(new_ps)
	print(new_us)	
	print(new_sigmas)



